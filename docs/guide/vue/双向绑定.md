# Vue3 双向绑定原理

Vue3 的源码构建方式发生了变化，双向绑定相关代码放到了 reactivity 包中。我们将从 reactive 函数和 effect 函数理解双向绑定。

## reactive && effect

reactive 函数接收一个对象作为参数，并返回一个代理对象。
effect 函数接收一个副作用函数。这个函数在响应式数据变化后会立即重新执行。它同时接收第二个可选参数，options 对象。用于配置副作用函数执行相关。

### reactive

```ts
// reactive 源码
export function reactive(target: object) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {
        return target;
    }
    return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
    );
}
```

reactive 函数先判断传入 target 是否为 readonly 对象，如果是，直接返回。

通过 createReactiveObject 函数创建真正的 reactive（shallowReactive, readonly, shallowReadonly 都是通过这个函数创建） 函数。

```ts
function createReactiveObject(
    target: Target,
    isReadonly: boolean,
    baseHandlers: ProxyHandler<any>,
    collectionHandlers: ProxyHandler<any>,
    proxyMap: WeakMap<Target, any>
) {
    // 不是对象直接返回
    if (!isObject(target)) {
        return target;
    }
    // 已经是代理对象，直接返回（readonly 已代理对象除外）
    if (target[ReactiveFlags.RAW] && !(isReadonly && target[ReactiveFlags.IS_REACTIVE])) {
        return target;
    }
    // target 已经有对应的代理
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
        return existingProxy;
    }
    // 只有白名单上的类型才能被代理
    const targetType = getTargetType(target);
    if (targetType === TargetType.INVALID) {
        return target;
    }
    const proxy = new Proxy(
        target,
        targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
}
```

核心代码为：

```ts
const proxy = new Proxy(
    target,
    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
);
proxyMap.set(target, proxy);
return proxy;
```

返回一个代理过的实例。根据对象的类型选用不同的代理函数。

由此我们产生了一个问题，这个实例代理了些什么属性。这就要看 collectionHandlers 和 baseHandlers（实际传入的对象名为：mutableCollectionHandlers、mutableHandlers），这两个对象的区别就是适用对象的类型，collectionHandlers 适用于 Map、Set、WeakMap、WeakSet，baseHandlers 适用于 Object、Array。

到这里 reactive 的工作就已经结束了。

### effect

```ts
export function effect<T = any>(
    fn: () => T,
    options?: ReactiveEffectOptions
): ReactiveEffectRunner {
    // 如果是一个存在 effect，对 fn 重新赋值
    if ((fn as ReactiveEffectRunner).effect) {
        fn = (fn as ReactiveEffectRunner).effect.fn;
    }
    // 床架你一个 ReactiveEffect 实例
    const _effect = new ReactiveEffect(fn);
    if (options) {
        extend(_effect, options);
        if (options.scope) recordEffectScope(_effect, options.scope);
    }
    // lazy 为 false 立即执行
    if (!options || !options.lazy) {
        _effect.run();
    }
    const runner = _effect.run.bind(_effect) as ReactiveEffectRunner;
    // 缓存实例
    runner.effect = _effect;
    return runner;
}
```

其中 extend 函数其实是 Object.assign 函数，用来合并 options 和实例的属性。

```ts
class Demo {
    foo = 1;
    constructor(bar) {
        this.bar = bar;
    }
}
const int = new Demo('aaa');
Object.assign(int, { foo: 2 });
console.log(int); // Demo { foo: 2, bar: 'aaa' }
```

### track

直接看 baseHandlers（mutableHandlers）。

```ts
export const mutableHandlers: ProxyHandler<object> = {
    get,
    set,
    deleteProperty,
    has,
    ownKeys,
};
```

我们可以看出 mutableHandlers 对 get、set、deleteProperty、has、ownKeys 进行了代理。

先看 get 和 set。

```ts
const get = /*#__PURE__*/ createGetter();
function createGetter(isReadonly = false, shallow = false) {
    return function get(target: Target, key: string | symbol, receiver: object) {
        const res = Reflect.get(target, key, receiver);

        if (!isReadonly) {
            track(target, TrackOpTypes.GET, key);
        }

        if (shallow) {
            return res;
        }

        if (isObject(res)) {
            // 将返回值转换为代理。对返回值做 isObject 检查避免无效值警告同时避免循环依赖
            return isReadonly ? readonly(res) : reactive(res);
        }

        return res;
    };
}
```

为了便于理解主流程，删除了一些边界处理逻辑，比如对象已经代理过，比如对象是个数组，比如 key 是个 Symbol 值。

由以上代码可以看出，去除对返回值的递归代理（proxy 只能代理一层，所以需要对类型为对象的值递归代理）其实只是执行了 track 函数。

```ts
export function track(target: object, type: TrackOpTypes, key: unknown) {
    if (!isTracking()) {
        return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
        targetMap.set(target, (depsMap = new Map()));
    }
    let dep = depsMap.get(key);
    if (!dep) {
        depsMap.set(key, (dep = createDep()));
    }

    const eventInfo = __DEV__ ? { effect: activeEffect, target, type, key } : undefined;

    trackEffects(dep, eventInfo);
}
```

由 track 函数中查找 dep 的过程，我们可以得出一个 targetMap 的结构。

targetMap -> target -> key -> createDep() => dep = new Set<ReactiveEffect>(effects) as Dep

targetMap 是一个 Map 类型，key 为 target， 值为 depsMap。depsMap 类型为 Map，key 为 target key，值为 dep，dep 为 Set 类型，值为 effect 副作用函数。

createDep 函数中有两个很关键的赋值操作。

```ts
export const createDep = (effects?: ReactiveEffect[]): Dep => {
    const dep = new Set<ReactiveEffect>(effects) as Dep;
    dep.w = 0;
    dep.n = 0;
    return dep;
};
/**
 * wasTracked and newTracked maintain the status for several levels of effect
 * tracking recursion. One bit per level is used to define whether the dependency
 * was/is tracked.
 */
type TrackedMarkers = {
    /**
     * wasTracked
     */
    w: number;
    /**
     * newTracked
     */
    n: number;
};
```

由注释我们可以知道 w, n 两个参数代表 wasTracked/newTracked。这两个参数维护了多个有关于 effect 的递归跟踪的状态。每级一个比特用于定义依赖是否被 track。

现在我们继续 track 函数的执行，跳过 eventInfo ，它是调试信息。执行 trackEffects 传入参数 dep。

```ts
export function trackEffects(dep: Dep, debuggerEventExtraInfo?: DebuggerEventExtraInfo) {
    let shouldTrack = false;
    if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
            dep.n |= trackOpBit; // set newly tracked
            shouldTrack = !wasTracked(dep);
        }
    } else {
        // Full cleanup mode.
        shouldTrack = !dep.has(activeEffect!);
    }

    if (shouldTrack) {
        dep.add(activeEffect!);
        activeEffect!.deps.push(dep);
        if (__DEV__ && activeEffect!.onTrack) {
            activeEffect!.onTrack(
                Object.assign(
                    {
                        effect: activeEffect!,
                    },
                    debuggerEventExtraInfo
                )
            );
        }
    }
}
```
