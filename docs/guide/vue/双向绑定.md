# Vue3 双向绑定原理

Vue3 的源码构建方式发生了变化，双向绑定相关代码放到了 reactivity 包中。我们将从 reactive 函数和 effect 函数理解双向绑定。

## reactive && effect

reactive 函数接收一个对象作为参数，并返回一个代理对象。
effect 函数接收一个副作用函数。这个函数在响应式数据变化后会立即重新执行。它同时接收第二个可选参数，options 对象。用于配置副作用函数执行相关。

### reactive

```ts
// reactive 源码
export function reactive(target: object) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {
        return target;
    }
    return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
    );
}
```

reactive 函数先判断传入 target 是否为 readonly 对象，如果是，直接返回。

通过 createReactiveObject 函数创建真正的 reactive（shallowReactive, readonly, shallowReadonly 都是通过这个函数创建） 函数。

```ts
function createReactiveObject(
    target: Target,
    isReadonly: boolean,
    baseHandlers: ProxyHandler<any>,
    collectionHandlers: ProxyHandler<any>,
    proxyMap: WeakMap<Target, any>
) {
    // 不是对象直接返回
    if (!isObject(target)) {
        return target;
    }
    // 已经是代理对象，直接返回（readonly 已代理对象除外）
    if (target[ReactiveFlags.RAW] && !(isReadonly && target[ReactiveFlags.IS_REACTIVE])) {
        return target;
    }
    // target 已经有对应的代理
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
        return existingProxy;
    }
    // 只有白名单上的类型才能被代理
    const targetType = getTargetType(target);
    if (targetType === TargetType.INVALID) {
        return target;
    }
    const proxy = new Proxy(
        target,
        targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
}
```

核心代码为：

```ts
const proxy = new Proxy(
    target,
    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
);
proxyMap.set(target, proxy);
return proxy;
```

返回一个代理过的实例。根据对象的类型选用不同的代理函数。

### effect

```ts
export function effect<T = any>(
    fn: () => T,
    options?: ReactiveEffectOptions
): ReactiveEffectRunner {
    // 如果是一个存在 effect，对 fn 重新赋值
    if ((fn as ReactiveEffectRunner).effect) {
        fn = (fn as ReactiveEffectRunner).effect.fn;
    }
    // 床架你一个 ReactiveEffect 实例
    const _effect = new ReactiveEffect(fn);
    if (options) {
        extend(_effect, options);
        if (options.scope) recordEffectScope(_effect, options.scope);
    }
    // lazy 为 false 立即执行
    if (!options || !options.lazy) {
        _effect.run();
    }
    const runner = _effect.run.bind(_effect) as ReactiveEffectRunner;
    // 缓存实例
    runner.effect = _effect;
    return runner;
}
```

其中 extend 函数其实是 Object.assign 函数，用来合并 options 和实例的属性。

```ts
class Demo {
    foo = 1;
    constructor(bar) {
        this.bar = bar;
    }
}
const int = new Demo('aaa');
Object.assign(int, { foo: 2 });
console.log(int); // Demo { foo: 2, bar: 'aaa' }
```
